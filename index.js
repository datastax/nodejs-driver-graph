/**
 * Copyright DataStax, Inc.
 *
 * Please see the license for details:
 * http://www.datastax.com/terms/datastax-dse-driver-license-terms
 */
'use strict';

const glv = require('gremlin');
const DseRemoteConnection = require('./lib/dse-remote-connection');
const dse = require('dse-driver');

/**
 * Returns the version of the package
 * @type {String}
 */
exports.version = require('./package.json').version;

/**
 * Creates an ExecutionProfile suitable for executing graph traversals as generated by
 * <code>queryFromTraversal()</code>.
 * @param {String} name Name of the execution profile.
 * @param {Object} options The options as defined in the
 * [DSE Driver]{@link http://docs.datastax.com/en/drivers/nodejs-dse/latest/ExecutionProfile.html}.
 * @example
 * const dse = require('dse-driver');
 * const dseGraph = require('dse-graph');
 * // Use a single Client instance
 * // Create the execution profile once using this method
 * const client = new dse.Client({
   *   contactPoints: ['h1', 'h2'],
   *   profiles: [
   *     dseGraph.createExecutionProfile('graph-oltp-traversal')
   *   ]
   * });
 * // Obtain a new traversal source.
 * const g = dseGraph.traversalSource(client);
 * const query = dseGraph.queryFromTraversal(g.V().hasLabel('person'));
 * // Reference the execution profile previously created.
 * client.executeGraph(query, null, { executionProfile: 'graph-oltp-traversal'}, function(err, result) {
   *   assert.ifError(err);
   *   console.log('User email ' + result.first().email);
   * });
 * @returns {ExecutionProfile}
 */
exports.createExecutionProfile = function createExecutionProfile(name, options) {
  options = extend({}, options);
  // Use 'bytecode-json' by default
  options.graphOptions = extend({ language: 'bytecode-json' }, options.graphOptions);
  return new dse.ExecutionProfile(name, options);
};

exports.predicates = require('./lib/predicates');

/**
 * Returns the string representation in GraphSON2 format of the traversal to be used in graph query executions.
 * @param traversal The Gremlin traversal instance to be converted to string.
 * @returns {String}
 */
exports.queryFromTraversal = function queryFromTraversal(traversal) {
  return DseRemoteConnection.getQuery(traversal);
};

/**
 * Creates a new graph traversal source.
 * If no arguments are provided, a simple and non-iterable traversal source is used.  This can be used to
 * generate queries using {@link queryFromTraversal()}.
 * Alternatively, providing a <code>dse.Client</code> and optionally <code>GraphQueryOptions</code> creates an iterable
 * traversal source that works with a remote DSE graph instance.
 * @param {Client} client The <code>dse.Client</code> instance.
 * @param {GraphQueryOptions} [options] The graph query options.
 * @returns {GraphTraversalSource} Returns an Apache TinkerPop GraphTraversalSource.
 */
exports.traversalSource = function traversalSource(client, options) {
  const traversalStrategies = new glv.process.TraversalStrategies();
  const remoteConnection = new DseRemoteConnection(client, options);
  traversalStrategies.addStrategy(new glv.driver.RemoteStrategy(remoteConnection));
  return new glv.process.GraphTraversalSource(null, traversalStrategies);
};

/**
 * Shallow clones multiple objects into one. Similar to Object.assign().
 * @private
 */
function extend(target) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function (source) {
    if (!source) {
      return;
    }
    const keys = Object.keys(source);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const value = source[key];
      if (value === undefined) {
        continue;
      }
      target[key] = value;
    }
  });
  return target;
}