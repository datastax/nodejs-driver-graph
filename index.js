/*
 * Copyright DataStax, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const glv = require('gremlin');
const { DseRemoteConnection, queryWriterFactory } = require('./lib/dse-remote-connection');
const { TraversalBatch } = require('./lib/types');
const { ExecutionProfile } = require('cassandra-driver');

const graphLanguage = 'bytecode-json';

/**
 * Returns the version of the package
 * @type {String}
 */
exports.version = require('./package.json').version;

/**
 * Creates an ExecutionProfile suitable for executing graph traversals as generated by
 * <code>queryFromTraversal()</code> and <code>queryFromBatch()</code>.
 * @param {String} name Name of the execution profile.
 * @param {Object} options The options as defined in the
 * [DataStax Driver]{@link https://docs.datastax.com/en/developer/nodejs-driver/latest/api/class.ExecutionProfile/}.
 * @example
 * const { Client } = require('cassandra-driver');
 * const dseGraph = require('cassandra-driver-graph');
 * // Use a single Client instance
 * // Create the execution profile once using this method
 * const client = new Client({
 *   contactPoints: ['h1', 'h2'],
 *   localDataCenter: 'my_graph_dc',
 *   profiles: [
 *     dseGraph.createExecutionProfile('graph-oltp-traversal')
 *   ]
 * });
 * // Obtain a new traversal source.
 * const g = dseGraph.traversalSource(client);
 * const query = dseGraph.queryFromTraversal(g.V().hasLabel('person'));
 * // Reference the execution profile previously created.
 * client.executeGraph(query, null, { executionProfile: 'graph-oltp-traversal'}, function(err, result) {
   *   assert.ifError(err);
   *   console.log('User email ' + result.first().email);
   * });
 * @returns {ExecutionProfile}
 */
exports.createExecutionProfile = function createExecutionProfile(name, options) {
  options = extend({}, options);
  // Use 'bytecode-json' by default
  options.graphOptions = extend({ language: graphLanguage }, options.graphOptions);
  return new ExecutionProfile(name, options);
};

exports.predicates = require('./lib/predicates');

/**
 * Returns the string representation in GraphSON2 format of the traversal to be used in graph query executions.
 * @param traversal The Gremlin traversal instance to be converted to string.
 * @param {string} [protocol] The graph protocol to use. Supported protocols are 'graphson-2.0' and 'graphson-3.0'.
 * @returns {String}
 */
exports.queryFromTraversal = function queryFromTraversal(traversal, protocol) {
  return DseRemoteConnection.getQuery(traversal, protocol);
};

/**
 * Returns a representation of the batch of traversals to be used in graph executions.
 * @param {Array} batch
 * @returns {Object}
 */
exports.queryFromBatch = function queryFromBatch(batch) {
  if (!Array.isArray(batch)) {
    throw new Error('Batch parameter must be an Array of traversals');
  }

  return { value: new TraversalBatch(batch), graphLanguage, queryWriterFactory };
};

/**
 * Creates a new graph traversal source.
 * If no arguments are provided, a simple and non-iterable traversal source is used.  This can be used to
 * generate queries using {@link queryFromTraversal()}.
 * Alternatively, providing a <code>Client</code> and optionally <code>GraphQueryOptions</code> creates an iterable
 * traversal source that works with a remote DSE graph instance.
 * @param {Client} client The <code>Client</code> instance.
 * @param {GraphQueryOptions} [options] The graph query options.
 * @returns {GraphTraversalSource} Returns an Apache TinkerPop GraphTraversalSource.
 */
exports.traversalSource = function traversalSource(client, options) {
  const traversalStrategies = new glv.process.TraversalStrategies();
  const remoteConnection = new DseRemoteConnection(client, options);
  traversalStrategies.addStrategy(new glv.driver.RemoteStrategy(remoteConnection));
  return new glv.process.GraphTraversalSource(null, traversalStrategies);
};

/**
 * Shallow clones multiple objects into one. Similar to Object.assign().
 * @private
 */
function extend(target) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function (source) {
    if (!source) {
      return;
    }
    const keys = Object.keys(source);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const value = source[key];
      if (value === undefined) {
        continue;
      }
      target[key] = value;
    }
  });
  return target;
}